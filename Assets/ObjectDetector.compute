#pragma kernel Preprocess
#pragma kernel Postprocess1
#pragma kernel Postprocess2

//
// Preprocessor
//

sampler2D _Texture;
RWBuffer<float> _Tensor;
uint _ImageSize;

[numthreads(8, 8, 1)]
void Preprocess(uint3 id : SV_DispatchThreadID)
{
    float2 uv = (id.xy + 0.5) / float2(_ImageSize, _ImageSize);
    uv.y = 1 - uv.y;

    float2 dx = float2(1.0 / _ImageSize, 0);
    float2 dy = float2(0, -1.0 / _ImageSize);

    float3 rgb = tex2Dgrad(_Texture, uv, dx, dy).rgb * 255;

    uint offs = (id.y * _ImageSize + id.x) * 3;
    _Tensor[offs + 0] = rgb.r;
    _Tensor[offs + 1] = rgb.g;
    _Tensor[offs + 2] = rgb.b;
}

// 
// 1st postprocessor (bounding box conversion)
//

#include "BoundingBox.hlsl"

Texture2D _Input;
AppendStructuredBuffer<BoundingBox> _Output;

#define CELLS_IN_ROW 13
#define CLASS_COUNT 20
#define ANCHOR_COUNT 5

float Sigmoid(float x)
{
    return 1 / (1 + exp(-x));
}

static float2 anchors[] = { float2(1.08, 1.19),
                            float2(3.42, 4.41),
                            float2(6.63, 11.38),
                            float2(9.42, 5.11),
                            float2(16.62, 10.52) };

[numthreads(CELLS_IN_ROW, CELLS_IN_ROW, 1)]
void Postprocess1(uint3 id : SV_DispatchThreadID)
{
    // We're not sure why but the direction of the tensor is flipped, so we
    // read them in the reversed order.
    uint ref_y = (CELLS_IN_ROW - 1 - id.y) * CELLS_IN_ROW +
                 (CELLS_IN_ROW - 1 - id.x);

    uint out_offs = ref_y * ANCHOR_COUNT;

    for (uint aidx = 0; aidx < ANCHOR_COUNT - 3; aidx++)
    {
        uint ref_x = aidx * (5 + CLASS_COUNT);

        // Bounding box / confidence
        float x = _Input[uint2(ref_x + 0, ref_y)].x;
        float y = _Input[uint2(ref_x + 1, ref_y)].x;
        float w = _Input[uint2(ref_x + 2, ref_y)].x;
        float h = _Input[uint2(ref_x + 3, ref_y)].x;
        float c = _Input[uint2(ref_x + 4, ref_y)].x;

        // ArgMax(SoftMax(classes))
        uint maxClass = 0;
        float maxScore = exp(_Input[uint2(ref_x + 5, ref_y)].x);
        float scoreSum = maxScore;
        for (uint cidx = 1; cidx < CLASS_COUNT; cidx++)
        {
            float score = exp(_Input[uint2(ref_x + 5 + cidx, ref_y)].x);
            bool take = score > maxScore;
            maxClass = take ? cidx : maxClass;
            maxScore = take ? score : maxScore;
            scoreSum += score;
        }

        // Output structure
        BoundingBox box;
        box.x = (id.x + Sigmoid(x)) / CELLS_IN_ROW;
        box.y = (id.y + Sigmoid(y)) / CELLS_IN_ROW;
        box.w = exp(w) * anchors[aidx].x / CELLS_IN_ROW;
        box.h = exp(h) * anchors[aidx].y / CELLS_IN_ROW;
        box.classIndex = maxClass;
        box.score = Sigmoid(c) * maxScore / scoreSum;

        // Thresholding
        if (box.score > 0.1) _Output.Append(box);
    }
}

//
// 2nd postprocessor (overlap removal)
//

ConsumeStructuredBuffer<BoundingBox> _Post2Input;
AppendStructuredBuffer<BoundingBox> _Post2Output;

#define MAX_DETECTION (CELLS_IN_ROW * CELLS_IN_ROW * ANCHOR_COUNT)

groupshared BoundingBox _post2_boxes[MAX_DETECTION];
groupshared bool _post2_flags[MAX_DETECTION];

float CalculateIOU(BoundingBox box1, BoundingBox box2)
{
    float x0 = max(box1.x - box1.w / 2, box2.x - box2.w / 2);
    float x1 = min(box1.x + box1.w / 2, box2.x + box2.w / 2);
    float y0 = max(box1.y - box1.h / 2, box2.y - box2.h / 2);
    float y1 = min(box1.y + box1.h / 2, box2.y + box2.h / 2);

    float area0 = box1.w * box1.h;
    float area1 = box2.w * box2.h;
    float areaInner = max(0, x1 - x0) * max(0, y1 - y0);

    return areaInner / (area0 + area1 - areaInner);
}

[numthreads(1, 1, 1)]
void Postprocess2(uint3 id : SV_DispatchThreadID)
{
    uint entry_count, stride;
    _Post2Input.GetDimensions(entry_count, stride);

    for (uint i = 0; i < entry_count; i++)
    {
        _post2_boxes[i] = _Post2Input.Consume();
        _post2_flags[i] = true;
    }

    for (i = 0; i < entry_count - 1; i++)
    {
        if (!_post2_flags[i]) continue;
        for (uint j = i + 1; j < entry_count; j++)
        {
            if (!_post2_flags[j]) continue;
            if (CalculateIOU(_post2_boxes[i], _post2_boxes[j]) < 0.3) continue;
            if (_post2_boxes[i].score < _post2_boxes[j].score)
            {
                _post2_flags[i] = false;
                break;
            }
            else
                _post2_flags[j] = false;
        }
    }

    for (i = 0; i < entry_count; i++)
        if (_post2_flags[i]) _Post2Output.Append(_post2_boxes[i]);
}
